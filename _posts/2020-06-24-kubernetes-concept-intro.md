--- 
layout: single
classes: wide
title: "[Kubernetes 개념] Kuternetes 란"
header:
  overlay_image: /img/kubernetes-bg.jpg
excerpt: '쿠버네티스란 무엇인가'
author: "window_for_sun"
header-style: text
categories :
  - Kubernetes
tags:
  - Kubernetes
  - Concept
  - Docker
toc: true
use_math: true
---  

## Container
리눅스에서는 프로세스에서 사용가능한 자원을 `cgroup` 과 특정 디렉토리 권한을 제한하는 `chroot` 등으로 격리환경 구성이 가능하다. 
그리고 디스크의 파일 변경사항을 레이어 형태로 저장하는 파일 시스템까지 통합해 컨테이너라는 개념이 생겨나게 되었다. 
`Docker` 는 앞에서 언급한 2가지 기능을 모아 컨테이너를 손쉽게 사용할 수 있도록 구현했다.  

![그림 1]({{site.baseurl}}/img/kubernetes/concept-intro-1.png)

위 그림은 컨테이너와 가상 머신과의 차이점을 표현하고 있는 그림이다. 
왼쪽이 컨테이너, 오른쪽이 가상 머신의 구조를 표현하고 있다.  

먼저 컨테이너는 호스트 운영체제 위에 `Docker`(컨테이너 런타임)이 위치하고, 그 위에서 컨테이너에 대응되는 애플리케이션이 구동된다. 
반면 가상 머신은 하이퍼바이저위에 각각의 게스트 운영체제를 띄우고 게스트 운영체제에서 각각의 애플리케이션이 구동되는 방식이다.  

또한 `Docker` 를 사용하면 컨테이너 이미지를 만들고 저장소에 올려 관리를 할 수도 있고, 
배포할 때 원격으로 필요한 이미지를 가져다가 쓸 수 있다. 
화물선박으로 사용하는 컨테이너와 이름이 비슷한 것처럼 규격화된 컨테이너를 만들고, 
실행이 필요한 호스트에 그대로 옮겨 실행만 하면 어느 곳이든지 실행이 가능하다. 

![그림 1]({{site.baseurl}}/img/kubernetes/concept-intro-2.png)

위 그림처럼 `Docker Engine` 은 서버-클라이언트 구조에서 아래와 같은 컴포넌트로 구성된다. 
- 서버의 역할로 계속해서 실행되어 있는 데몬 프로세스(`dockerd`)
- 데몬 프로세스에게 요청에 대한 인터페이스로 제공되는 `REST API`
- `CLI` 를 통해 명령을 내리는 클라이언트(`docker`)

![그림 1]({{site.baseurl}}/img/kubernetes/concept-intro-3.png)

컨테이너와 컨테이너 오케스트레이션을 사용하면 개발 및 운영 환경 구축을 위해 반복하던 설정과 설치의 어려움을 어느정도 해소 할 수 있다. 

## Container Orchestration
컨테이너라는 개념이 새로운 것은 아니지만, 도커는 이를 사용하기 편하게 만들어 대중성을 확보해 전체 개발 과정에 걸쳐 큰 변화를 가져다 주었다. 
컨테이너를 통해 개발 환경과 운영 환경의 차이로 발생하는 장애를 극복 할 수 있다. 
하지만 이러한 컨테이너의 장점에도 불구하고, 
컨테이너만을 가지고 실제 상용 서비스를 운영하기에는 부족한 부분이 있다. 
이러한 부족한 점을 채워 주는 것이 바로 `Container Orchestration` 이다.  

![그림 1]({{site.baseurl}}/img/kubernetes/concept_intro_plant_1.png)

위 그림은 컨테이너를 사용했을 때의 고전적인 상용 서비스의 구성이다. 
컨테이너 이미지를 생성하고 이를 저장소에 올린 후, 
서버 여러 대에 수동으로 배포한다. 
그리고 장애가 발생해서 컨테이너를 새로 생성하고 복구하는 것또한 수동으로 해야 한다.  

컨테이너 오케스트레이션 시스템을 사용하게 되면 수동으로 제어하던 부분을 자동화 처리가 가능하다. 
상용 서비스로 사용할 서버가 몇대가 됐건 클러스터로 구성하면 명령어를 통해 자동 배포를 할 수 있다. 
서비스 중인 클러스터 일부에 장애가 발생하더라도 오케스트레이션 시스템을 통해 장애가 발생한 노드에 있는 컨테이너를 다른 노드로 옮겨 실행 한다. 
이러한 방식으로 개발자는 서비스의 안정성을 컨터이너 오케스트레이션에게 맡기고 장애 발생 지점 파악에 더욱 집중 할 수 있다. 

## Kuternetes
`Kuternetes` 는 조타수라는 그리스어로 구글에서 기존에 사용하던 보그라는 시스템을 공개한 오픈소스이다. 
쿠버네티스는 `k` 와 `s` 사이에 글자가 8글자가 있다고해서 `k8s` 라고 표기하기도 한다. 
포켓몬 고, GitHub 등이 쿠버네티스로 옮겨 성공적인 서비스를 했다는 사례도 있다. 
국내에서도 카카오 등에서도 쿠버네티스를 적극적으로 활용중에 있다. 
또한 구글 클라우드 플랫폼, 마이크로소프트 애저, 아마존 웹 서비스에서도 쿠버네티스 관리헝 서비스를 제공 중에 있다. 

### 선언적 API
쿠버네티스의 설계 원칙은 `선언적 API` 이다. 
컨테이너가 어떤 상태이길 설정하면 지속적으로 컨테이너의 상태를 확인하고, 
설정 된 상태가 아니라면 상태에 맞추는 방식이다.  
1. 설정한 상태로 맞추기
1. 현재 상태 확인
1. 설정한 상태와의 차이 확인
1. 반복

10개의 컨테이너가 실행되야 한다고 설정이 돼있는 상태에서, 
장애가 발생해 구성된 클러스터의 노드의 리소스가 부족하다고 가정한다. 
리소스가 부족해 8개의 컨테이너만 구동중이라면, 
쿠버네티스는 클러스터에 추가적인 노드를 할당하고 2개의 컨테이너를 실행해 설정된 10개의 컨테이너가 만족 될 수 있도록 처리한다.  

쿠버네티스의 시스템의 구성하고 있는 노드들간의 네트워크 문제가 있는 상태라고 가정한다. 
클러스터를 구성하는 일부노드에 명령이 전달되지 못해 정상적인 수행을 못하더라도,
클러스터가 정상적으로 동작중이라면 이러한 문제는 쿠버네티스가 알아서 복구하고 처리하게 된다.  

이런 선언적 특성은 간단한 처리에서 불편함을 주기도 한다. 
일반적인 재시작 같은 동작에서 쿠버네티스는 기존 설정과 같은 경우 재시작은 불필요하다고 판단하기 때문에 재시작이 불가능하다. 
1.15 버전부터 디플로이먼트, 스테이트풀세트, 데몬세트에 애노테이션을 변경하면서 재시작 동작을 제어할 수 있게 되었다. 

### 워크로드 분리
쿠버네티스는 운영체와 같이 분산된 프로세스의 관리를 추상화하는 레이어를 통해 시스템 운영에 대한 고민을 덜어 준다. 
각각의 분산 프로세스가 잘 동작하는지, 이슈가 발생했을 때의 대응과 안정성에 대한 고민을 쿠버네티스에게 맡길 수 있다. 

### 커뮤니티
활성화된 커뮤니티를 통해 필요한 지원을 언제든지 받을 수 있다. 
오픈소스이기 때문에 커뮤니티는 누구나 참여가능하고 원한다면 기여하는 것도 가능하다. 
GitHub, Slack, Facebook 등을 통해 커뮤니티의 일원이 될 수 있다.

---
## Reference
[쿠버네티스란 무엇인가?](https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/)