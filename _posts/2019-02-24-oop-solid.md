--- 
layout: single
classes: wide
title: "객체 지향 프로그래밍(OOP) 객체 지향 디자인 5원칙(SOLID 원칙)"
header:
  overlay_image: /img/oop-bg.jpg
subtitle: 'SOLID 란 무엇이고, 어떠한 특징을 가지고 있는지'
author: "window_for_sun"
header-style: text
categories :
  - OOP
tags:
    - OOP
    - 객체 지향
    - SOLID
    - 디자인 패턴
    - Design Pattern
---  

'SOLID 란 무엇이고, 어떠한 특징을 가지고 있는지'

# 객체 지향 디자인 원칙
> 좋은 객체 지향 설계를 위해서는 다음 5가지 원칙을 따르는 것이 좋고, 다음의 원칙을 기반으로 다자인 패턴이 되기 때문에, 디자인 패턴을 공부하기 전에 알아두면 왜 그 패턴이 좋은 패턴인지에 대해서 좀 더 깊이 이해할 수 있다.  

객체 지향 5가지의 원칙, 앞글자를 따서 SOLID라고도 한다.

## S - SRP(Single Responsibility Principle) 단일 책임 원칙
### 요약
- 모든 클래스는 단 하나의 책임을 가진다. 다시 말하면 클래스를 수정할 이유는 오직 하나여야 한다는 뜻이기도 하다.
- 예를 들어, 계산기 클래스가 있을 때, 계산을 하는 책임과 GUI를 나타낸다는 책임은 서로 분리되어야 한다. 계산기 클래스에 GUI를 나타내는 부분까지 있는 경우, 이는 SRP르 위반한다.

### 상세
1. 정의
	- 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
	- 어떤 변화에 의해 클래스를 변겨여해야 하는 이유는 오직 하나뿐이어야 함을 의미
	- SRP원리를 적용하면 무엇보다도 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로움
	- 책임을 적절히 분배함으로써 코드의 가독성 향상, 유지보수 용이라는 이점을 누릴 수 있고, 객체 지향 원리의 OCP원리뿐 아니라 다른 원리들의 기초가 됨
	- 실무 프로세스는 매우 복잡 다양하고 변경 또한 빈번하기 때문에 간단하지만 직접 적용 및 설계가 어려움
	- 평소에 많은 연습(책임이란 단어를 상기하는)과 경험이 필요함
1. 적용 방법
	- 리팩토링(Refactoring)에서 대부분의 상황에 대한 해결방법은 직/간접/적으로 SRP원리와 관련이 있으며, 이는 항상 코드를 최상으로 유지한다는 리팩토링의 근본정신도 항상 객체들의 책임을 최상위 상태로 분배한다는 것에서 비롯 된다.
		- 여러 원인에 의한 변경(Divergent Change)
			- Extract Class를 통해 혼재된 각 책임을 각각의 개별 클래스로 분할하여 클래스 당 하나의 책임만을 맡도록 하는 것이다.
			- 책임만 분리하는 것이 아니라, 분리된 두 클래스간의 관계 복잡도를 줄이도록 설계해야 한다.
			- Extract Class 된 각각의 클래스들이 유사하고 비슷한 책임을 중복해서 갖고 있다면 Extract SuperClass를 사용할 수 있다.
				- Extract 된 각각의 클래스들에서 공유되는 요소를 부모 클래스로 정의하여 부모 클래스에 위임한다.
				- 각각의 Extract Class 들의 유사한 책임들은 부모에게 위임하고 다른 책임들은 각자에게 정의 할 수 있다.
		- 산탄총 수술(Shotgun Surgery)
			- Move Field와 Move Method를 통해 책임을 기존의 어떤 클래스로 모으거나, 새로운 클래스를 만드는 것이다.
			- 산발적으로 여러 곳에 분포된 책임들을 한 곳에 모으면서 설계를 깨끗하게 하여 응집성을 높이는 작업을 수행한다.
1. 예시
	- SRP 적용 전
		- ![OOP SOLID SRP 예시1]({{site.baseurl}}/img/oop-solid-srp-ex-1-classdiagram.png)
	
		```java
		class Guitar {
			private String serialNumber;
			private Double price;
			private Maker maker;
			private Type type;
			private String model;
			private Wood topWood;
			private Wood backWood;
			private int stringNum;
			
			// construct, getter, setter, etc ...
		}
		```  
	
		- serailNumber는 변화 요소가 아닌 고유정보이다. 
		- serialNumber를 제외한 price, maker, type 등은 모두 특성 정보군으로 변경이 발생 할 수 있는 변화 요소이다.
		- 특성 정보군에 변화가 발생하면 항상 해당 클래스를 수정해야 하므로 SRP 적용 대상이 된다.
	- SRP 적용 후
		- ![OOP SOLID SRP 예시2]({{site.baseurl}}/img/oop-solid-srp-ex-2-classdiagram.png)
	
		```java
		class Guitar {
			private String serialNumber;
			private GuitarSpec guitarSpec;
			
			// construct, getter, setter, etc ...
		}
		
		class GuitarSpec {
	        private Double price;
	        private Maker maker;
	        private Type type;
	        private String model;
	        private Wood topWood;
	        private Wood backWood;
	        private int stringNum;
	        
	        // construct, getter, setter, etc ...
	    }
		```  
		
		- 위와 같은 분리를 통해 특성 정보 변경이 일어나 더라도 GuitarSpec 클래스만 변경하면 된다.
		- 변화에 의해 변경되는 부분을 한곳에서 관리 할 수 있게 되었다.
1. 적용 이슈
- 클래스는 자신의 이름을 나타내는 책임이 있어야 한다.
- 올바른 클래스 이름은 해당 클래스의 책임을 나타낼 수 있는 가장 좋은 방법이다.
- 각 클래스는 하나의 개념을 나타내어야 한다.
- 무조건 책임을 분리한닫고 SRP가 적용되는 것은 아니다.
- 개체 간의 응집력이 있다면 병합이 순 작용의 수단이고, 결합력이 있다면 분리가 순 작용의 수단이 된다. (?)

## O - OCP(Open Close Principle) 개방 폐쇄 원칙
### 요약
- 확장에 대해서는 개방 되어 있어야 하지만, 수정에 대해서는 폐쇄 되어야 한다.
- 예를 들어, 캐릭터를 하나 생성한다고 할때, 각각의 캐릭터가 움직임이 다를 경우 움직임의 패턴 구현을 하위 클래스에서 맡긴다면 캐릭터 클래스의 수정은 필요가 없고(수정에 대해 폐쇄) 움직임의 패턴만 재정의 하면된다.(확장에 대해 개방)

### 상세
1. 정의
	- 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리이다.
	- 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비ㅣ용은 가능한 극대화 해야 한다는 의미이다.
	- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어아지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻이다.
	- 로버트 C.마틴은 OCP는 관리가능하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케 하는 중요 메커니즘은 추상화와 다형성이라고 설명하고 있다.
	- OCP는 객체 지향의 장점을 극대화하는 아주 중요한 원리이다.
1. 적용 방법
	- 변경(확장)될 것과 변하지 않을 것을 엄격히 구분한다.
	- 이 두 모듈이 만나는 지점에 인터페이스를 정의한다.
	- 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성 한다.
1. 예시
	- OCP 적용 전
		- ![OOP SOLID OCP 예시1]({{site.baseurl}}/img/oop-solid-ocp-ex-1-classdiagram.png)
		```java
		public class Guitar {
			private GuitarSpec guitarSpec;
			// Property, Method ..
		}
		public class GuitarSpec {
			// Property, Method ..
		}
		public class Violin {
			private ViolinSpec violinSpec;
			// Property, Method ..
		}
		public class ViolinSpec {
			// Property, Method ..
		}
		```  
		- SRP에서 변경을 최소화 하는 클래스 구조로 분리 하였지만 Guitar 외에 바이올린, 첼로 등 다양한 악기가 추가 되었을 경우 위처럼 설계될 수 있다.
		- Guitar와 추가 될 다른 악기들을 추상화하는 작업이 필요하다.
	- OCP 적용 후
		- ![OOP SOLID OCP 예시2]({{site.baseurl}}/img/oop-solid-ocp-ex-2-classdiagram.png)
		
		```java
		public abstract class Instrument {
			private String serialNumber;
			private InstrumentSpec instrumentSpec;
			
			// Property, Method ..
		}
		public abstract class InstrumentSpec {
			private double price;
			private String model;
			
			// Property, Method ..
		}
		public class Guitar extends Instrument {
			// Property. Method ..
		}
		public class Violin extends Instrument {
			// Property, Method ..
		}		
		public class GuitarSpec extends InstrumentSpec {
			// Property, Method ..
		}
		public class ViolinSpec extends InstrumentSpec {
			// Property, Method ..
		}
		```  
		
		- 악기들의 공통 속성을 모두 담는 Instrument라는 인터페이스(예시에서는 추상 클래스)를 정의 한다.
		- 악기 특성 정보를 담는 InstrumenSpec 이라는 인터페이스(예시에서는 추상 클래스)도 정의한다.
		- 새로운 악기가 추가 되면서 변경이 발생하는 부분을 추상화 하여 분리 함
		- 코드의 수정을 최소화 하여 결합도는 줄이고 응집도는 높이는 효과를 가져옴
1. 적용 이슈
	- 확장되는 것과 변경되지 않는 모듈을 분리하는 과정에서 관계가 더 복잡해 질 수 있다.
	- 인터페이스는 변경 되어서는 안된다.
	- 인터페이스 설계에서 적당한 추상화 레벨을 선택해야 한다.
		- 추상화란 다른 모든 종류의 객체로부터 식별될 수 있는 객체의 본질적인 특성
		- 행위에 대한 본질적인 정의를 통해 인터페이스를 식별해야 한다.
	
## L - LSP(Liskov Substitution Principle) 리스코프 치환 원칙
### 요약
- 자식 클래스는 언제나 자신의 부모 클래스를 교체할 수 있어야 한다.
- 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 동작해야 한다.
- 업캐스팅을 해도 아무런 문제가 안되어야 한다.

```java
Student s = new Student();
Persion p = (Student)s;
```  

- 도형 예시
	- 도형 클래스와 사각형 클래스가 있고, 사각형 클래스는 도형 클래스를 상속한다고 가정하자.
		1. 도형은 둘레를 가지고 있다.
		1. 도형은 넓이를 가지고 있다.
		1. 도형은 각을 가지고 있다.
	- 일반화 관계(일관성이 있는지 확인하는 방법은 단어를 교체해 보면 알 수 있다.) 위의 1~3의 도형이란 단어 대신 사각형을 넣어보자.
		1. 사각형은 둘레를 가지고 있다.
		1. 사각형은 넓이를 가지고 있다.
		1. 사각형은 각을 가지고 있다.
	- 1~3 모두 이상한 부분이 없다. 따라서 도형과 사각형 사이에는 일관성이 있다고 할 수 있다.
	- 원(Circle) 이라는 도형 또한 도형 클래스를 상속받는다고 가정하고, 1~3의 도형 단어 대신 원을 넣어보자.
		1. 원은 둘레를 가지고 있다.
		1. 원은 넓이를 가지고 있다.
		1. 원은 각을 가지고 있다.
	- 3번 문장이 어색하다는 것을 알 수 있다. 따라서 도형 클래스는 LSP를 만족하지 않은 설계라 할 수 있다.
	- 3번 문장에 대해서 일반화 관계가 성립하도록 도형 클래스는 수정이 필요하다.

### 상세
> *참고  
> 인터페이스 상속 : 순수 가상 함수의 상속
> 구현 상속 : 가상 함수와 비가상 함수의 상속  
> 순수 가상 : 가상함수나, 함수의 정의부분이 없고, 선언 부분만 있는 함수  
> 가상 함수 : 파생 클래스에서 가상 함수가 없다면, 기본 클래스 함수가 호출되고, 있다면 파생 클래스의 가상 함수를 호출시켜주는 매체가 되는 함수  
> 비 가상 함수 : 일반 멤버 함수  
> 사전 조건(Precondition) : 해당 연산이 호출되기 전 만족해야하는 조건이며 이 조건이 만족하지 않을 시 연산을 호출하면 안된다는 의미  
> 사후 조건(Postcondition) : 연산이 수행되고 나서 반드시 만족해야하는 조건을 의미한다.  

1. 정의
	- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
	- 서브 타입은 기반 타입과 호환될 수 있어야 한다.
	- 상속 구현 상속(extends), 인터페이스 상속(implements)은 궁극적으로 다형성을 통한 확장성 확득이 목표이다.
	- LSP 원리도 하위 클래스가 확장에 대한 상위 클래스를 준수해야 함을 의미한다.
	- 다형성과 확장성을 극대화 하려면 하위 클래스 사용보다는 상위 클래스 사용이 더 좋다.
	- 상속을 통한 재사용은 상위 클래스와 서브 클래스 사이에 IS-A관계가 있을 경우로만 제한 되어야 한다.
	- IS-A 관계 아닐 경우에는 합성(Composition)을 이용한 재사용을 해야 한다.
	- LSP는 OCP를 구상하는 구조가 되어, 다형성을 통한 확장 원리인 OCP를 제공한다.
		- 상속은 다형성과 따로 생각할 수 없고, 다형성을 위해서는 하위 클래스가 상위 클래스의 규약을 지켜야 하기때문이다.
	- 객체 지향 설계원리는 LSP를 통해 OCP를 제공하는 것처럼 서로가 서로를 이용하고 포함하는 특징을 가지고 있다.
1. 적용 방법
	- 두 개체가 같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 둔다.
	- 같은 연산을 제공하지만, 다르게 동작한다면 공통 인터페이스를 만들고 두 개체가 이를 구현한다. (인터페이스 상속)
	- 공통 연산이 없다면, 완전 별개인 2개의 클래스를 만든다.
	- 두 개체가 하는 일에 추가적인 연산이 필요하다면 구현 상속을 사용한다.
1. 예시
	- 컬렉션 프레임워크
		```java
		public class MyArray {
			private LinkedList array = new LinkedList();
			
			public void add(Object o) {
				this.array.add(o);
			}
		}
		```  
		
		- MyArray에서 List만 사용할 것이라면 문제가 없다.
		- 속도 개선을 위해 HashSet을 사용해야 하는 경우 처럼 변경이 잦다면, LinkedList와 HashSet이 모두 상속하고 있는 Collection 으로 변경하는 것이 바람직하다.
		
		```java
		public class MyArray {
			private Collection array = new HashSet();
			
			public void add(Object o) {
				this.array.add(0);
			}
		}
		```  
		
		- 위 코드는 LSP와 OCP 모두 찾아볼 수 있다.
		- 컬렉션 프레임워크가 LSP를 준수하지 않았다면 위 코드처럼 범용적 작업은 불가능하다. (LSP)
		- add() 메서드는 변화에 닫혀 있으면서, 컬력션의 변경과 확장에는 열려 있는 구조이다. (OCP)
1. 적용 이슈 
	- 트레이드 오프를 고려해야 한다면 그대로 둔다.
	- 다형성을 위한 상속 관계가 필요 없다면 Replace With Delegation 을 이용한다.
		- 상속은 깨지기 쉬운 기반 클래스 등을 포함하고 있으므로 IS-A 관계가 성립되지 않는다.
		- LSP 를 지키기 힘들다면 상속대신 합성(Composition)을 사용하는 것이 좋다.
	- 상속 구조가 필요 하다면 Extract SubClass, Push Down Field, Push Down Method 등의 리팩토링 기법을 이용하여 LSP 를 준수하는 사아속 계층 구조를 구성한다.
	- IS-A 관계 맺음은 이들의 역할과 이들 사이에 공유하는 연산이 있는지, 그리고 이들 연산이 어떻게 다른지 등 종합적으로 검토 해야 한다.
	- Design By Contract : 하위 클래스에서는 상위 클래스의 사전 조건과 같거나 더 약한 수준에서 사전 조건을 대체할 수 있고, 상위 클래스의 사후 조건과 같거나 더 강한 수준에서 사후 조건을 대체 할 수 있다.
		- 하위 클래스를 상위 클래스로 치환 가능하게 하려면, 사전 조건에서 하위 클래스의 제약사항이 상위 클래스의 제약 사항보다 느슨하거나 같아야 한다.
		- 하위 클래스의 사전 조건의 제약조건이 더 강하면 상위 클래스에서 실행되는 것이 하위 클래스의 강 조건으로 인해 실행되지 않을 수 있다.
		- 하위 클래스의 사후 조건은 같거나 더 강해야 하는데, 약하다면 상위 클래스의 사후 조건이 통과시키지 않는 상태를 통과 시킬 수 있기 때문이다.
	
## I - ISP(Interface Segregation Principle) 인터페이스 분리 원칙
### 요약
- 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.
- 클래스는 자신이 사용하지 않는 인터페이스(기능)를 구현하지 않아야 한다. 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.
- 자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 않아아 한다는 의미이다.
- ex)
	- 스마트폰으로 전화, 인터넷, 촬영 등 다양한 기능을 사용 할 수 있다.
	- 전화를 사용할 때는 인터넷, 촬영 등 다른 기능은 사용하지 않는다.
	- 전화, 인터넷, 촬영 기능은 각각 독립된 인터페이스로 구현하여, 서로에게 영향을 받지 않도록 설계해야 한다.
	- 이렇게 설계된 ISP원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.
	
### 상세
1. 정의
	- ISP 원칙은 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙이다.
	- 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만 사용해야 한다.
	- 어떤 클래스를 이용하는 클라이언트가 여러 개고 이들이 해당 클래스의 특정 부분집합만을 이용한다면, 이들을 따로 인터페이스를 빼내어 클라이언트가 기대하는 메시지만을 전달 할 수 있도록 한다.
	- SRP가 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일책임을 강조한다.
	- SRP가 클래스 분리를 통해 변화의 적응성을 획득하는 반면, ISP는 인터페이스 분리를 통해 같은 목표를 도달한다.
1. 적용 방법
	- 클래스 인터페이스를 통한 분리
		- 클래스의 상속을 이용하면 인터페이스를 나눌 수 있다.
		- 이는 클라이언트에게 변화를 주지 않을 뿐 아니라, 인터페이스를 분리하는 효과를 얻는다.
		- 객체지향 언어에서 상속을 이용한 확장은 상속 받는 클래스의 성격을 디자인 시점에 규정한다.
		- 인터페이스를 상속받는 순간 인터페이스에 예속되어 제공하는 서비스의 성격이 제한된다.
	- 객체 인터페이스를 통한 분리
		- 위임(Delegation)을 이용하여 인터페이스를 나눌 수 있다.
		- 위임이란, 특정 일의 책임을 다른 클래스나 메소드에 맡기는 것이다.
		- 다른 클래스의 기능을 사용해야 하지만, 그 기능을 변경하고 싶지 않다면 상속 대신 위임을 사용한다.
1. 예시
	- Java Swing의 JTable
		- JTable 클래스에는 많은 메소드들이 있다.
		- 컬럼 추가, 셀 에디터 리스너 부착 등 여러 역할이 하나의 클래스 안에 있다.
		- JTable의 입장에서 본다면 모두 제공해야 하는 역할이다.
		- JTable은 ISP가 제안하는 방식으로 모든 인터페이스 분리를 통해 특정 역할만 이용하는 것을 제공한다.
		- Accessible, CellEditorListener, ListSelectionListener, Scrollable, TableColumnModelListener, TableModelListener 등 여러 인터페이스 구현을 통해 서비스를 제공한다.
		- JTable은 자신을 이용하여 테이블을 만드는 객체(모든 서비스를 필요로 하는)에게는 기능 전부를 노출하지만, 이벤트 처리와 관련해서는 여러 리스너 인터페이스를 통해 해당 기능만 노출한다.
		
		```java
		public class SimpleTableDemo ... implements TableModelListener {
			...
			public SimpleTableDemo() {
				table.getModel().addTableModelListener(this);
			}
	
			@Override
			public void tableChanged(TableModelEvent e) {
				....
			}
		}
		```  
		
1. 적용 이슈
	- 구현된 클라이언트에 변경을 주지 말아야 한다.
	- 두 개 이상의 인터페이스가 공유하는 부분의 재사용을 극대화 한다.
	- 서로 다른 성격의 인터페이스를 명확히 분리한다.
	

## D - DIP(Dependency Inversion Principle) 의존성 역전 원칙
### 요약
- 상위클래스는 하위 클래스에 의존해서는 안된다는 원칙
- 하위 클래스가 상위클래스에 의존을 해야지 상위 클래스가 하위클래스에 의존해서는 안된다.

### 상세
> A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS  
> B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTION  

1. 정의
	- DI 의존관계의 역전이란 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전입니다.
	- 실제 사용 관계는 바꾸지 않으며, 추상 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙입니다.
	- DIP의 키워드는 IOC, 훅(hook) 메소드(슈퍼 클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 하위 클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드), 확장성 이다.
	- 위 세가지 요소가 조합되어 복잡한 컴포넌트들의 관계를 단순화하고 컴포넌트 간의 커뮤니케이션을 효율적이게 한다.
	- Callee와 Caller
		- Callee 컴포넌트(혹은 프레임워크)는 Caller 컴포넌트들이 등록할 수 있는 인터페이스를 제공한다.
		- Callee는 Caller들의 컨테이너 역할이 된다.
		- Callee 컴포넌트는 Caller 컴포넌트가 확장(구현)할, 그리고 IOC를 위한 훅 메소드 인터페이스를 정의한다.
		- Caller 컴포넌트는 정의된 훅 메소드를 구현한다.
		- 위의 단계까지 DIP를 위한 준비가 완료 되었다.
		- Caller는 Callee에 자신을 등록한다.
		- Callee는 Caller에게 정보를 제공할 적당한 시점에 Caller의 훅 메소드를 호출한다.
		- 이 시점이 Caller와 Callee의 호출관계가 역전되는 IOC 시점이다.
	- DIP 가 사용되는 경우
		- 비동기적으로 커뮤니케이션이 이루어져도 될 혹은 이뤄져야할 경우
		- 컴포넌트 간의 커뮤니케이션이 복잡할 경우
		- 컴포넌트 간의 커뮤니케이션이 비효율적일 경우
	- DIP는 복잡하고 어려운 컴포넌트간의 커뮤니케이션 관계를 단순화하기 위한 원칙이다.
1. 적용 방법
> Grady Booch(Object Solutions, Addison Wesly, 1996, p54)는 "... all webb structured object-oriented architectures have clearly-defined layers, with each layer providing some coherent set of services though a well-defined and controlled interface"  

- 잘 구조화된 객체 지향 아키텍처들은 각 레이어마다 잘 정의되고 통제되는 인터페이스를 통한 긴밀한 서비스들의 집합을 제공하는 레이어들로 구성되어 있다.
	- 단순히 레이어를 통한 구조화만을 뜻하는 것이 아니다.
	- Transitive Dependency가 발생했을 때 상위 레벨의 레이어가 하위 레벨의 레이어를 바로 의존하는 것이 아니다.
	- 그 둘 사이에 존재하는 추상레벨을 통해 의존해야 할 것들을 말하고 있는 것이다.
- 상위 레벨의 모듈은 하위 레벨의 모듈로의 의존성에서 벗어나 그 자체로 재사용 되고 확장성도 보장 받을 수 있다.
- DIP 적용 전
	- ![OOP SOLID DIP 적용전1]({{site.baseurl}}/img/oop-solid-dip-beforedip-1-classdiagram.png)
- DIP 적용 후
	- ![OOP SOLID DIP 적용후1]({{site.baseurl}}/img/oop-solid-dip-afterdip-1-classdiagram.png)

1. 예시
	- 통신 프로그래밍 모델
		- 소켓 프로그램은 클라이언트가 서버에게 요청(send())하고 서버로부터 결과(recv())를 받으므로 서버의 서비스를 이용한다.
		- 멀티 스레드 프로그래밍에서 send(), recv()를 하게 되면 recv()함수는 블럭 되기 때문에 recv()하는 동안 스레드는 서버의 응답이 오기까지 대기한다.
		- 서버로 부터 응답을

---
## Reference
[객체지향 개발 5대 원리: SOLID](http://www.nextree.co.kr/p6960/)  
[객체지향 디자인의 5원칙(SOLID 원칙)](https://wkdtjsgur100.github.io/solid-principle/)  
[[소프트웨어 공학] 클래스 다이어그램(Class Diagram) -1 (클래스란?, UML에서 클래스 표기법)](https://m.blog.naver.com/PostView.nhn?blogId=ljh0326s&logNo=221001979745&proxyReferer=https%3A%2F%2Fwww.google.com%2F)  