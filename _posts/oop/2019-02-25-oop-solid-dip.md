--- 
layout: single
classes: wide
title: "객체 지향 프로그래밍(OOP) 객체 지향 디자인 5원칙(SOLID 원칙) - DIP"
header:
  overlay_image: /img/oop-bg.jpg
excerpt: 'SOLID-DIP 란 무엇이고, 어떠한 특징을 가지고 있는지'
author: "window_for_sun"
header-style: text
categories :
  - OOP
tags:
    - OOP
    - DIP
    - 객체 지향
    - SOLID
    - 디자인 패턴
    - Design Pattern
---  

### [SOLID 개요]({{site.baseurl}}{% link _posts/oop/2019-02-24-oop-solid.md %})

## D - DIP(Dependency Inversion Principle) 의존성 역전 원칙
> A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS  
> B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTION  

1. 정의
	- DI 의존관계의 역전이란 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전입니다.
	- 실제 사용 관계는 바꾸지 않으며, 추상 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙입니다.
	- DIP의 키워드는 IOC, 훅(hook) 메소드(슈퍼 클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 하위 클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드), 확장성 이다.
	- 위 세가지 요소가 조합되어 복잡한 컴포넌트들의 관계를 단순화하고 컴포넌트 간의 커뮤니케이션을 효율적이게 한다.
	- Callee와 Caller
		- Callee 컴포넌트(혹은 프레임워크)는 Caller 컴포넌트들이 등록할 수 있는 인터페이스를 제공한다.
		- Callee는 Caller들의 컨테이너 역할이 된다.
		- Callee 컴포넌트는 Caller 컴포넌트가 확장(구현)할, 그리고 IOC를 위한 훅 메소드 인터페이스를 정의한다.
		- Caller 컴포넌트는 정의된 훅 메소드를 구현한다.
		- 위의 단계까지 DIP를 위한 준비가 완료 되었다.
		- Caller는 Callee에 자신을 등록한다.
		- Callee는 Caller에게 정보를 제공할 적당한 시점에 Caller의 훅 메소드를 호출한다.
		- 이 시점이 Caller와 Callee의 호출관계가 역전되는 IOC 시점이다.
	- DIP 가 사용되는 경우
		- 비동기적으로 커뮤니케이션이 이루어져도 될 혹은 이뤄져야할 경우
		- 컴포넌트 간의 커뮤니케이션이 복잡할 경우
		- 컴포넌트 간의 커뮤니케이션이 비효율적일 경우
	- DIP는 복잡하고 어려운 컴포넌트간의 커뮤니케이션 관계를 단순화하기 위한 원칙이다.
1. 적용 방법
> Grady Booch(Object Solutions, Addison Wesly, 1996, p54)는 "... all webb structured object-oriented architectures have clearly-defined layers, with each layer providing some coherent set of services though a well-defined and controlled interface"  

- 잘 구조화된 객체 지향 아키텍처들은 각 레이어마다 잘 정의되고 통제되는 인터페이스를 통한 긴밀한 서비스들의 집합을 제공하는 레이어들로 구성되어 있다.
	- 단순히 레이어를 통한 구조화만을 뜻하는 것이 아니다.
	- Transitive Dependency가 발생했을 때 상위 레벨의 레이어가 하위 레벨의 레이어를 바로 의존하는 것이 아니다.
	- 그 둘 사이에 존재하는 추상레벨을 통해 의존해야 할 것들을 말하고 있는 것이다.
- 상위 레벨의 모듈은 하위 레벨의 모듈로의 의존성에서 벗어나 그 자체로 재사용 되고 확장성도 보장 받을 수 있다.
- DIP 적용 전
	- ![OOP SOLID DIP 적용전1]({{site.baseurl}}/img/oop-solid-dip-beforedip-1-classdiagram.png)
- DIP 적용 후
	- ![OOP SOLID DIP 적용후1]({{site.baseurl}}/img/oop-solid-dip-afterdip-1-classdiagram.png)

1. 예시
	- 통신 프로그래밍 모델
		- 소켓 프로그램은 클라이언트가 서버에게 요청(send())하고 서버로부터 결과(recv())를 받으므로 서버의 서비스를 이용한다.
		- 멀티 스레드 프로그래밍에서 send(), recv()를 하게 되면 recv()함수는 블럭 되기 때문에 recv()하는 동안 스레드는 서버의 응답이 오기까지 대기한다.
		- 서버로 부터 응답을 대기하는 동안 recv()를 호출한 스레드는 다른 작업을 할수 없기 때문에 스레드 자원이 낭비된다.
		- 위 문제의 대안으로 제시되는 모델이 폴링(polling) 모델이다.
			- 클라이언트 스레드는 서버에게 메시지를 보내고 recv()를 전담하는 스레드에게 recv()를 맡긴다.
			- 클라이언트 스레드느 다른 작업을 수행하며 서버로부터 응답을 확인하고 싶은 시점에 전달된 서버의 메시지를 가져온다.
			- 이런 폴링 모델은 특정 시점에 클라이언트 스레드는 서버의 응답을 확인해야 한다.
			- 자신이 원하는 시점에 서버의 응답을 확인한다는 장점과 응답을 기다리는 시간에 다른 작업을 할 수 있는 장점이 있다.
			- 모든 통제가 클라이언트 스레드 스케쥴 안에 있고, 동기적(원하는 시점)으로 서버의 응답을 확인할 수 있다.
			- 서버의 응답이 예상보다 지연될 경우 클라이언트 스레드는 서버의 응답이 올때까지 지속적으로 응답 큐를 확인해야 한다.
			- 서버 응답 확인 시점이 동기적일 필요가 없을 경우 더욱 불필요한 작업이라는 것이 명확해 진다.
			- 이렇게 서버의 응답 처리가 비 동기적으로 처리 되야 할때, 클라이언트 스레드가 서버 응답 확인 시도가 여러번 발생할 때 폴링 모델은 오버해드가 발생한다.
		- 다른 대안으로 DIP 를 적용한 비 동기 소켓 모델이다.
			- 클라이언트 스레드는 메시지를 send() 후 recv()하는 대신 서버의 응답을 처리하는 훅 메소드를 등록한다.
			- 구조적 프로그래밍에서는 함수 포인터, 객체 지향에서는 커멘트 오브젝트를 등록한다.
			- recv()를 담당하는 스레드는 서버로부터 응답을 받으면 대응하는 훅 메소드를 찾아 실행한다.
			- recv() 스레드는 서버의 응답 수신과 훅 메소드 실행을 담당한다.
			- 클라이언트 스레드의 잦은 응답 확인을 제거 할 수 있다.
			- 클라이언트 스레드는 응답 확인하는 작업에서 자유로워지므로 다른 작업을 수행 할 수 있다.
			- 이런 구조 바탕에는 통제권이 클라이언트 스레드에서 커멘드 오브젝트로 역전되는 IOC 가 전제된다.
			- DIP를 적용할 때 장점은 퍼포먼스를 높일 수 있고, 여청에 대한 응답으로부터 관심을 제거해 클라이언트의 역할을 단순화 하는데 있다.
	- 이벤트 드리븐, 콜벡, JMS 모델
		- 자바 스윙의 이벤트 모델에는 DIP의 원리가 녹아 있다.
			- 이벤트를 처리할 java.awt.event.ActionListener 를 등록(addActionListener())한다.
			- 이벤트가 발생하면 등록된 ActionListener의 훅 메소드인 actionPerform()를 후킹한다.
			- 복수 개의 이벤트를 위한 복수 개의 ActionListener도 등록할 수 있다.
			- 이와 유사한 구조로 Observer & Observable 인터페이스도 있고, 분산 시스템에도 똑같은 구조가 적용 된다.
		- 비 동기적인 분산 후킹(콜백) 구조
			- 서버-클라이언트 통신에 있어 클라이언트는 서버에 자신의 원격 객체 레퍼런스를 등록한다.
			- 서버는 자신의 작업을 진행하며 원격 객체 레퍼런스를 통해 그때그때 필요한 정보를 클라이언트에게 제공한다.
			- 이를 위해 클라이언트의 콜백(Callback) 메소드가 미리 정의되어야 한다.
			- 콜백 메소드는 서버가 비 동기적으로 클라이언트에게 정보를 전달하는 훅 메소드가 된다.
			- 콜백의 구조는 원격지에서 훅킹이 제공되는 형태를 갖는다.
			- 서버에 장시간 작업들을 할당하고 클라이언트가 각 작업의 결과에 대한 중간 보고를 받고 싶을 때 유용하다.
			- 클라이언트의 호출이 비 동기적이기 때문에 서버의 작업을 할당한 다음 클라이언트는 다시 자신의 작업이 진행된다.
			- 위의 예인 소켓의 비 동기 모델에서 recv() 스레드가 서버의 역할로 전이된 형태를 갖는다.
		- JMS의 토픽 모델- 전통적인 MOM 아키텍처에서 Pub/Sub 메시징 모델
			- 메시지 지향 미들웨어, 분산 응용 프로그램 간에 메시지를 전송 및수신하여 데이터 통신과 교환
			- 멀티캐스팅 같은 그룹 메시징 제공 시 유용함
			- 주식정보 시스템을 예로 든다면, 정보 제공자는 가입한 모든 클라이언트에게 현재 증시 정보를 멀티캐스팅 한다.
			- 제공자는 Publisher가 되고 클라이언트 프로그램은 Subscribe가 된다.
			- 이 모델의 장점은 클라이언트-서버에서 메시지 기반으로 패러다임이 바뀐다는 것이다.
			- 기존의 클라이언트-서버 모델은 서버가 클라이언트를 상대하는 구조이다.
			- Pub/Sub 모델에서는 클라이언트-서버간의 상호의존도가 제거 되고, 서버는 각종 클라이언트들에게 메시지를 보내는 것이 아니라 정보라는 메시지를 보내면 된다.
			- 클라이언트들이 얼마나 접속해 있는지, 기타 클라이언트 관련 정보 등은 관심 대상에서 제외되고 메시지에 관심을 집중한다.
			- Subscribe들은 Topic 제공자에게 자신을 등록한다.
			- Publisher가 Topic 제공자에게 메시지를 전송하면 JMS Topic 제공자는 등록된 Subscriber 들에게 메시지를 멀티캐스팅 한다.
			- 메시지 멀티캐스팅을 하기 위해 등록된 각 Subscriber 들은 onMessage()를 호출하게 된다.
			

---
## Reference
[객체지향 개발 5대 원리: SOLID](http://www.nextree.co.kr/p6960/)  